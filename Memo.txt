CR639
D:解なしの条件をよく吟味する。

CR638
C:条件を順を追って考える。空文字列はNGなので、まず小さい方から1文字ずつ割り当てる。この時点でのminとmaxが一致していない場合、maxをminに何を加えてもmaxは不変なので、残りは全てminに押し付ければよい。
一致している場合、残った文字が全て同じならバランス良く割り当てれば良い。異なる文字が混ざっている場合、それをできるだけ後ろに持っていきたいので、1つのaに全て押し付ければ良い。

CR619
C:余事象。n個をm人になるべく平等に配ろうとすると、まず全員にn/m個配った後でn%m人に1つずつ追加することになる。
D:最初から答えを構成しようとするとハマる。最大でもstep数が<1e+5であることを利用し、まずstepを圧縮せずに構成する。その後連続する文字を置き換えればよい。

CR618
D:点対称の条件は、対応する点の中点同士が一致すること（「対応する点を結ぶ線が1点で交わること」ではない（cf:四角形））。

CR439
E:2次元BIT。「区間Addと1点取得」がしたい場合は、
・更新時に区間の端に±1を置く
・取得時に左上からのsumを得る
ことで代用できる。
ex)左上からの和を考えれば、長方形内だけ+1になることがわかる。
    -----------
    |+1       |-1
    |         |
    -----------
     -1        +1

またこの問題では各バリアをAddしていき、queryでは「高さ」が等しいことを確認すれば良さそうだが、異なるバリアにより同じ高さになっている場合で落ちる。そこでバリアごとに固有の高さを割り当てる=乱数を使うと良いが、それでもintの場合は和がたまたま一致することがよく起こる。よってlong longの乱数を使うと良い。

ECR087
D:lower_boundを積んだBIT。セグ木では間に合わない。

ECR082
B:過半数がgoodの条件で答えを出し、もしn未満ならnにすればよい。