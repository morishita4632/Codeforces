CR646
D:coutはfflush(stdout)ではなくcout.flush()を使う。インタラクティブ問題は2分探索！
E:順に考える。まずaは親の値が小さければそれに置き換えることができる。これにより同じ処理をするなら葉に近いところから貪欲にやればよいことがわかる。これを再帰で実装。構造体を作って渡すよりはグローバルにメモした方が楽そう。その場合は再帰部分で手動で拾う必要がある。

CR645
C:sumの値は抜けがないので、maxとminがわかればmax-min+1が個数になる。さらにこの数を図からうまく長方形の面積に帰着させる。

CR644
H:長さ固定なら 辞書順=算術順 になる。二分探索では条件を満たす最大(or最小)がわかるので、今回のように抜けがある場合でもデクリメントしながら探せばOK。
もしくは今回は消す数がとても少ないので、元のmedianと削除後のmedianはそれほど離れていない。よって全探索で間に合う。

CR641
D:0と+の間に-がある場合がややこしいが、例えば「++-」を「+++」にできることに気づけば簡単

CR639
D:解なしの条件をよく吟味する。

CR638
C:条件を順を追って考える。空文字列はNGなので、まず小さい方から1文字ずつ割り当てる。この時点でのminとmaxが一致していない場合、maxをminに何を加えてもmaxは不変なので、残りは全てminに押し付ければよい。
一致している場合、残った文字が全て同じならバランス良く割り当てれば良い。異なる文字が混ざっている場合、それをできるだけ後ろに持っていきたいので、1つのaに全て押し付ければ良い。
D:2のべき乗で作れるだけ作り、残りを挿入したあとソートすると天才。

CR619
C:余事象。n個をm人になるべく平等に配ろうとすると、まず全員にn/m個配った後でn%m人に1つずつ追加することになる。
D:最初から答えを構成しようとするとハマる。最大でもstep数が<1e+5であることを利用し、まずstepを圧縮せずに構成する。その後連続する文字を置き換えればよい。

CR618
D:点対称の条件は、対応する点の中点同士が一致すること（「対応する点を結ぶ線が1点で交わること」ではない（cf:四角形））。

CR439
E:2次元BIT。集合の区別に乱数を用いる問題。
「区間Addと1点取得」がしたい場合は、
・更新時に区間の端に±1を置く
・取得時に左上からのsumを得る
ことで代用できる。
ex)左上からの和を考えれば、長方形内だけ+1になることがわかる。
    -----------
    |+1       |-1
    |         |
    -----------
     -1        +1

またこの問題では各バリアをAddしていき、queryでは「高さ」が等しいことを確認すれば良さそうだが、異なるバリアにより同じ高さになっている場合で落ちる。そこでバリアごとに固有の高さを割り当てる=乱数を使うと良いが、それでもintの場合は和がたまたま一致することがよく起こる。よってlong longの乱数を使うと良い。それでも怖いならllのpairを使えば完璧。

ECR088
D:最大部分配列問題。Kadane's Algorithm。Bobが除く要素Aについて全探索する発想はOK。それを決めると、Aより大きい要素を-INFに置き換えた上で最大部分配列問題に帰着する（当然最後にAを引くのを忘れない）。

ECR087
D:lower_boundを積んだBIT。セグ木では間に合わない。

ECR082
B:過半数がgoodの条件で答えを出し、もしn未満ならnにすればよい。